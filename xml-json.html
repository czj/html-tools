<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML ↔ JSON</title>
    <link rel="stylesheet" href="common.css">
    <style>
        body {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .container {
            flex: 1;
            display: flex;
            gap: 20px;
            min-height: 0;
        }

        .pane {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        textarea {
            flex: 1;
            min-height: 300px;
        }

        .pane-header .actions {
            display: flex;
            gap: 8px;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }

            .pane {
                min-height: 280px;
            }
        }
    </style>
</head>
<body>

    <a href="index.html" class="back-link">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M19 12H5M12 19l-7-7 7-7"/>
        </svg>
        All Tools
    </a>

    <header>
        <h1>XML ↔ JSON</h1>
        <p class="subtitle">Convert between XML and JSON formats</p>
    </header>

    <div class="container">
        <div class="pane">
            <div class="pane-header">
                <span class="label">XML</span>
                <div class="actions">
                    <button class="copy-btn" id="copyXml">Copy</button>
                </div>
            </div>
            <div id="xmlError" class="error-message"></div>
            <textarea id="xmlInput" placeholder="Enter XML here..." spellcheck="false" aria-label="XML input"></textarea>
        </div>

        <div class="pane">
            <div class="pane-header">
                <span class="label">JSON</span>
                <div class="actions">
                    <button class="copy-btn" id="copyJson">Copy</button>
                </div>
            </div>
            <div id="jsonError" class="error-message"></div>
            <textarea id="jsonInput" placeholder="Enter JSON here..." spellcheck="false" aria-label="JSON input"></textarea>
        </div>
    </div>

    <script>
        const xmlInput = document.getElementById('xmlInput');
        const jsonInput = document.getElementById('jsonInput');
        const xmlError = document.getElementById('xmlError');
        const jsonError = document.getElementById('jsonError');
        const copyXml = document.getElementById('copyXml');
        const copyJson = document.getElementById('copyJson');

        let updating = false;

        // XML to JSON conversion
        function xmlToJson(xml) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(xml, 'text/xml');

            // Check for parse errors
            const parseError = doc.querySelector('parsererror');
            if (parseError) {
                throw new Error('Invalid XML: ' + parseError.textContent.split('\n')[0]);
            }

            function nodeToObject(node) {
                const obj = {};

                // Handle attributes
                if (node.attributes && node.attributes.length > 0) {
                    obj['@attributes'] = {};
                    for (const attr of node.attributes) {
                        obj['@attributes'][attr.name] = attr.value;
                    }
                }

                // Handle child nodes
                for (const child of node.childNodes) {
                    if (child.nodeType === Node.TEXT_NODE) {
                        const text = child.textContent.trim();
                        if (text) {
                            // If there are no other properties, return just the text
                            if (Object.keys(obj).length === 0 && node.childNodes.length === 1) {
                                return text;
                            }
                            obj['#text'] = text;
                        }
                    } else if (child.nodeType === Node.ELEMENT_NODE) {
                        const childObj = nodeToObject(child);
                        const tagName = child.tagName;

                        if (obj[tagName] !== undefined) {
                            // Convert to array if multiple elements with same name
                            if (!Array.isArray(obj[tagName])) {
                                obj[tagName] = [obj[tagName]];
                            }
                            obj[tagName].push(childObj);
                        } else {
                            obj[tagName] = childObj;
                        }
                    } else if (child.nodeType === Node.CDATA_SECTION_NODE) {
                        obj['#cdata'] = child.textContent;
                    } else if (child.nodeType === Node.COMMENT_NODE) {
                        // Skip comments
                    }
                }

                return Object.keys(obj).length === 0 ? '' : obj;
            }

            const result = {};
            result[doc.documentElement.tagName] = nodeToObject(doc.documentElement);
            return result;
        }

        // JSON to XML conversion
        function jsonToXml(json, indent = 2) {
            function escapeXml(str) {
                return String(str)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&apos;');
            }

            function objectToXml(obj, tagName, level = 0) {
                const spaces = ' '.repeat(level * indent);
                const childSpaces = ' '.repeat((level + 1) * indent);

                if (obj === null || obj === undefined) {
                    return `${spaces}<${tagName}/>\n`;
                }

                if (typeof obj !== 'object') {
                    return `${spaces}<${tagName}>${escapeXml(obj)}</${tagName}>\n`;
                }

                if (Array.isArray(obj)) {
                    return obj.map(item => objectToXml(item, tagName, level)).join('');
                }

                let xml = `${spaces}<${tagName}`;
                let children = '';
                let textContent = '';

                for (const [key, value] of Object.entries(obj)) {
                    if (key === '@attributes') {
                        for (const [attrName, attrValue] of Object.entries(value)) {
                            xml += ` ${attrName}="${escapeXml(attrValue)}"`;
                        }
                    } else if (key === '#text') {
                        textContent = escapeXml(value);
                    } else if (key === '#cdata') {
                        children += `${childSpaces}<![CDATA[${value}]]>\n`;
                    } else {
                        children += objectToXml(value, key, level + 1);
                    }
                }

                if (children || textContent) {
                    xml += '>';
                    if (textContent && !children) {
                        xml += textContent + `</${tagName}>\n`;
                    } else {
                        xml += '\n' + children + (textContent ? `${childSpaces}${textContent}\n` : '') + `${spaces}</${tagName}>\n`;
                    }
                } else {
                    xml += '/>\n';
                }

                return xml;
            }

            const keys = Object.keys(json);
            if (keys.length === 0) {
                throw new Error('JSON object is empty');
            }

            let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
            for (const key of keys) {
                xml += objectToXml(json[key], key, 0);
            }
            return xml.trim();
        }

        function updateFromXml() {
            if (updating) return;
            updating = true;

            xmlError.style.display = 'none';
            jsonError.style.display = 'none';

            const xml = xmlInput.value.trim();
            if (!xml) {
                jsonInput.value = '';
                updating = false;
                return;
            }

            try {
                const json = xmlToJson(xml);
                jsonInput.value = JSON.stringify(json, null, 2);
            } catch (e) {
                xmlError.textContent = e.message;
                xmlError.style.display = 'block';
            }

            updating = false;
        }

        function updateFromJson() {
            if (updating) return;
            updating = true;

            xmlError.style.display = 'none';
            jsonError.style.display = 'none';

            const json = jsonInput.value.trim();
            if (!json) {
                xmlInput.value = '';
                updating = false;
                return;
            }

            try {
                const parsed = JSON.parse(json);
                xmlInput.value = jsonToXml(parsed);
            } catch (e) {
                jsonError.textContent = e.message;
                jsonError.style.display = 'block';
            }

            updating = false;
        }

        // Event listeners
        xmlInput.addEventListener('input', updateFromXml);
        jsonInput.addEventListener('input', updateFromJson);

        // Copy buttons
        function setupCopyButton(btn, textarea) {
            btn.addEventListener('click', () => {
                if (!textarea.value) return;
                navigator.clipboard.writeText(textarea.value).then(() => {
                    const originalText = btn.textContent;
                    btn.textContent = 'Copied!';
                    btn.classList.add('copied');
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.classList.remove('copied');
                    }, 2000);
                });
            });
        }

        setupCopyButton(copyXml, xmlInput);
        setupCopyButton(copyJson, jsonInput);
    </script>
</body>
</html>
